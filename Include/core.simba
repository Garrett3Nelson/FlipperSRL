procedure tScript.initPlayer();
begin
  if not grandExchange.Open() then
  begin
    self.print('Did not open GE successfully', eDebugType.FATAL);
    terminateScript();
  end;

  // First time through read the cash. This does absolutely nothing right now
  if self.playerCash = 0 then
    self.playerCash := grandExchange.readCash();

  if self.playerCash = 0 then
  begin
    self.print('YOU HAVE NO MONEY', eDebugType.FATAL);
    terminateScript();
  end;

  // Check if there are slots to load
  if (self.countActiveSlots() <> self.countFreeSlots()) then
  begin
    // What do we want to do if there are active slots?
  end;

  self.print('initPlayer(): init Completed');
end;

procedure TScript.Free();
begin
  RSClient.Image.Clear();
  Self.Print('You did great out there');
  self.itemMap.Free();
end;

function tGEOffer.doBuyCheck(): Boolean;
begin
  if self.slotNumber = -1 then self.slotNumber := grandExchange.nextEmptySlot();

  if not grandExchange.CreateBuyOffer(self.item.name, '+20', 1, self.slotNumber) then
  begin
    writeln('getBuyPrice(): Failed doing buy offer');
    grandExchange.ReturnToMain();
    exit(False);
  end;

  //self.print('getBuyPrice(): Bought item, waiting for it to complete');

  if not waitUntil(grandExchange.getProgress(self.slotnumber) = 100, 250, 2000) then
  begin
    writeln('Offer did not purchase');
    grandExchange.AbortOffer(self.slotnumber);
  end;

  if not grandExchange.CollectOffer() then
    writeln('Warning: Buy offer did not collect');

  result := waitUntil(grandExchange.GetOfferStatus(self.slotnumber).OfferType = ERSGEOfferType.EMPTY, 250, 2000);
end;

function tGEOffer.doSellCheck(): Boolean;
begin
  // For tracking the slot that will be used
  // clicking the item in the inventory will create an offer in this slot
  if self.slotNumber = -1 then
    self.slotNumber := grandExchange.nextEmptySlot();

  if not grandExchange.CreateSellOffer(self.item.name, '-20', 1) then
  begin
    grandExchange.ReturnToMain();
    Exit(False);
  end;

  if not waitUntil(grandExchange.getProgress(self.slotnumber) = 100, 250, 2000) then
  begin
    writeln('Offer did not sell');
    grandExchange.AbortOffer(self.slotnumber);
  end else
    if not grandExchange.CollectOffer() then
      writeln('Warning: Sell offer did not collect');

  result := waitUntil(grandExchange.GetOfferStatus(self.slotnumber).OfferType = ERSGEOfferType.EMPTY, 250, 2000);
end;

function TGEOffer.doPricecheck() : Boolean;
var
  history : TRSGEHistory;
begin

  if GrandExchange.GetCurrentInterface() <> ERSGEInterface.OVERVIEW then grandExchange.ReturnToMain();

  self.slotNumber := grandExchange.nextEmptySlot();

  if self.doBuyCheck() then
    if self.doSellCheck() then
    begin
      grandExchange.changeTab();
      wait(random(400,800));

      history := grandExchange.GetHistory();
      grandExchange.changeTab(False);
      wait(random(400,800));

      self.item.buy := history[1].PricePerItem;
      self.item.sell := history[0].PricePerItem;

      result := True;
    end;
end;

// Count how many slots have active offers
function tScript.countActiveSlots() : Int32;
begin
end;

// Count how many slots are empty
function tScript.countFreeSlots() : Int32;
begin
end;


(*
tScript.updateTrades
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tScript.updateTrades();
Removes any items from the recentItem array that were traded more than 4 hours ago.
*)

procedure tScript.updateTrades();
var
  cutoff, lim, i : Integer;
begin
  cutoff := getSystemUnix() - (4*60*60*1000); // 4 hour cutoff for trades

  lim := high(self.recentItems);

  for i := lim downto 0 do
    if self.recentItems[i].tradeFinished < cutoff then // if it's been longer than 4 hours
      self.recentItems.deleteIndex(i);
end;

(*
tScript.addTrade
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tScript.addTrade(trade : tTradeRecord);
Adds a given tradeRecord to the recentItem list.
*)

procedure tScript.addTrade(constref trade : tTradeRecord);
begin
  if trade.amount <= 0 then
    self.print("ERROR: Cannot add trade of 0 amount")
  else
    self.recentItems.append(trade);

  self.updateTrades(); // Update to remove any old trades
end;

(*
tScript.encodeItems
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   function tScript.encodeItems() : String;
Encodes the trade data to be sent to the database to prevent checking out an item
that was recently traded. Used in importItemFancy.
*)

function tScript.encodeItems() : String;
var
  i, lim : Integer;
begin
  // Remove any old trades before we send the list
  self.updateTrades();

  if length(self.recentItems) = 0 then
    exit("1:"); // We send a placeholder text for this function.
  // The database needs a placeholder item so we send 1 because there is no itemID 1 in the database.

  lim := high(self.recentItems);
  for i := 0 to lim do
    result += toStr(self.recentItems[i].amount) + ":";
    // For this function we are only sending the itemID separated by ":"
end;
