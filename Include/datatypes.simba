(*
tTradeRecord Functions
-------------------
*)

(*
CreateTradeRecord
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   function createTradeRecord(time, amount : Int32) : tTradeRecord;
Used to convert integer values to tTradeRecord format for use in tracking
*)

function tGEOffer.createTradeRecord(history : tGEHistory) : tTradeRecord;
begin
  with Result do
  begin
    offerID := self.globalID;
    timeStampUnix := getSystemUnix();
    timeStamp := FormatDateTime('yyyy-mm-dd hh:mm:ss', Now());
    itemName := self.item.name;
    itemID := self.item.itemID;
    OfferType := history.OfferType;
    Quantity := history.Quantity;
    PricePerItem := history.PricePerItem;
    TotalPrice := history.TotalPrice;
  end;
end;

function tTradeRecord.stringify() : String;
begin
  result := self.OfferType + ': Quantity = ' + toStr(self.Quantity) + ', Price = ' + toStr(self.TotalPrice) + ' (' + toStr(self.PricePerItem) +' ea), Recorded at ' + toStr(self.TimeStamp);
end;

(*
tTradeRecordArray.Append
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tTradeRecordArray.append(const trade : tTradeRecord);
Appends a trade record to the end of the array
*)

procedure tTradeRecordArray.append(constref trade : tTradeRecord);
begin
  insert(trade, self, length(self));
end;

procedure tTradeRecordArray.updatePriceCheck(offer : tGEOffer);
var i, matches : Int32;
begin
  for i := high(self) downto 0 do
  begin
    if (self[i].OfferID = -1) and (self[i].itemID = offer.item.itemID) then
    begin
      self[i].OfferID := offer.globalID;
      matches += 1;
    end;

    if matches = 2 then exit;
  end;
end;

(*
tTradeRecordArray.deleteIndex
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tTradeRecordArray.deleteIndex(const index : Integer);
Deletes a trade record from the list (after it is past 4 hours)
*)

procedure tTradeRecordArray.deleteIndex(const index : Integer);
begin
  if not inRange(index, low(self), high(self)) then
  begin
    //tScript.print('ERROR: deleteIndex: index out of bounds.');
    exit();
  end;

  delete(self, index, 1);
end;

(*
tGEItemArray.Append
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEItemArray.append(const item : tGEItem);
Appends an item to the end of the array
*)

procedure tGEItemArray.append(constref item : tGEItem);
begin
  insert(item, self, length(self));
end;

(*
tGEItemArray.deleteIndex
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEItemArray.deleteIndex(const index : Integer);
Deletes an item from the array, used for clearing return items
*)

procedure tGEItemArray.deleteIndex(const index : Integer);
begin
  if not inRange(index, low(self), high(self)) then
  begin
    //tScript.print('ERROR: deleteIndex: index out of bounds.');
    exit();
  end;

  delete(self, index, 1);
end;

 (*
tGEItem Functions
-------------------
*)


(*
tGEItem.initFlip
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEItem.initFlip();
Once the pricecheck is complete, the flip is set up so that we sell at the
auto-buy price and buy at the auto-sell price.
*)

procedure tGEItem.initFlip();
var
  temp_buy, temp_sell : Integer;
begin
  if self.buy < self.sell then // if buy is lower that means we've already set up the price
    //tScript.print("Item was set up for flipping already")
  else begin
    temp_buy := min(self.sell, self.buy) + 1; // The low price is for buying
    temp_sell := max(self.sell, self.buy) - 1; // The high price is for selling
    self.buy := temp_buy;
    self.sell := temp_sell;
  end;
end;

(*
tGEItem.margin
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   function tGEOffer.margin() : Extended;
Calculates the margin possible for the item. Used after pricechecking.
*)

function tGEItem.margin() : Extended;
begin
  if min(self.buy, self.sell) = 0 then
    Result := 0.0
  else if (self.buy > self.sell) then // If the item is set for a pricecheck
    Result := 100*(self.buy - self.sell - 2 - self.tax) / self.sell
  else if (self.sell > self.buy) then // If the item is set for a flip (doesn't need -2 because it's already happened)
    Result := 100*(self.sell - self.buy - self.tax) / self.buy;
    // The min/max are used to ensure we calculate the right method (higher - lower)/lower
    // margin := (revenue-spend-2)/spend
    // The 2 is subtracted because when we set up for flip we're going to reduce by 1gp on each side
    // Which gives us the best offer on the GE and a faster flip.
end;

function tGEItem.stringify() : String;
begin
  result := self.name + ": ID = " + toStr(self.itemID) + ", Market = " + toStr(self.market) + ", Buy = " + toStr(self.buy) + ", Sell = " +toStr(self.sell) + ', Margin = ' + toStr(round(self.margin(), 3)) + ", Tax: " + toStr(self.tax) + ", Limit: " + toStr(self.limit);
end;

(*
tGEItem.debug
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   function tGEItem.debug() : String;
Puts the important info about an item into a nice readable string. It reports
itemID, name, market, buy/sell, margin, and limit.
*)

procedure tGEItem.debug();
begin
  print(self.stringify());
end;

 (*
tGEOffer Functions
-------------------
*)

(*
tGEOffer.initTime
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEOffer.initTime();
Used to mark the startTime of the offer. Reset() will set to 0 so it needs to be
set when the offer actually starts.
*)

procedure tGEOffer.initTime();
begin
  self.startTime := getSystemUnix();
  self.lastUpdate := self.startTime; // At the beginning these are the same
end;


(*
tGESlot.debug
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   function tScript.debug() : String;
Puts the important info about a slot into a nice readable string. It reports
slot number, status, last progress.
*)

procedure tGESlot.debug();
begin
  print(toStr(self));
end;

function tGEOffer.stringify(i : Int32; collected : Boolean = True; full: Boolean = False) : String;
begin
  if full then
    result := 'Offer ' + '[' + toStr(i) + ']: ' + toStr(self.globalID) + '. Status = ' + self.status + '. slotNumber = ' + toStr(self.slotNumber) + '. toTrade = ' + toStr(self.toTrade) + '. Purchased = ' + toStr(self.purchased) + '. Spent: ' + toStr(self.spent) + '. Revenue: ' + toStr(self.revenue) + '. Profit: ' + toStr(self.revenue-self.spent) + '. Time: ' + toStr(round((getSystemUnix() - self.startTime)/1000)) + 's'
  else
    result := 'Offer ' + '[' + toStr(i) + ']: ' + toStr(self.globalID) + '. Status = ' + self.status + '. slotNumber = ' + toStr(self.slotNumber) + '. toTrade = ' + toStr(self.toTrade) + '. Purchased = ' + toStr(self.purchased) + '. Spent: ' + toStr(self.spent) + '. Revenue: ' + toStr(self.revenue);
  if collected then
    result += '. Collected: ' + toStr(self.collected) +'. History Updated: ' + toStr(self.HistUpdated);
  if length(InvSlots) > 0 then
    result += '. InvSlots = ' + toStr(self.InvSlots);
end;

(*
tGEOffer.debug
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEOffer.debug();
Puts the important info about an offer into a nice readable string. It reports
tradeID, status, toTrade, and purchased.
*)

procedure tGEOffer.debug(i : Int32);
begin
  print(self.stringify(i));
  self.item.debug();
  self.slot.debug();
end;

(*
tGEOfferArray.debug
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEOfferArray.debug();
Debugs all offers.
*)

procedure tGEOfferArray.debug(Force : Boolean = False);
var
  i, lim : Int32;
begin
  lim := high(self);
  for i := 0 to lim do
    if Force or (self[i].status <> 'empty') then
      self[i].debug(i);
end;

procedure tGEOfferArray.append(constref offer : tGEOffer);
begin
  insert(offer, self, length(self));
end;

(*
tGEOfferArray.countCollected
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   function tGEOfferArray.countCollected();
Counts how many offers are marked collected internally.
*)

function tGEOfferArray.countCollected() : Integer;
var
  i, lim : Int32;
begin
  lim := high(self);
  for i := 0 to lim do
    if self[i].collected then inc(result);
end;

function tGEOfferArray.ListCollectedBuys() : tIntegerArray;
var
  i, lim : Int32;
begin
  lim := high(self);
  for i := 0 to lim do
    if (self[i].aborted and (self[i].purchased > 0)) or (self[i].collected and (self[i].status = 'buying')) then result.append(i);
end;

(*
tGEOfferArray.countCollected
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   function tGEOfferArray.countActive();
Counts how many active offers we think we have.
*)

function tGEOfferArray.countActive() : Integer;
var i : Integer;
begin
  for i := 0 to high(self) do
    if ((self[i].globalID > 0) and (self[i].status <> 'empty')) then
      result += 1;
end;

// Returns a tIA of the trading slot numbers
function tGEOfferArray.CountTrading() : tIntegerArray;
var
  i : Integer;
begin
  for i := 0 to high(self) do
    if ((self[i].slot.OfferType <> ERSGEOfferType.EMPTY) and (self[i].slot.OfferType <> ERSGEOfferType.UNKNOWN)) then result.append(self[i].slotNumber);
end;

function tGEOfferArray.CountComplete() : tIntegerArray;
var
  i : Integer;
begin
  for i := 0 to high(self) do
    if (self[i].slot.Progress = 100) then result.append(self[i].slotNumber);
end;

function tGEOfferArray.CountChanged() : tIntegerArray;
var
  i : Integer;
begin
  for i := 0 to high(self) do
    if (self[i].slot.Progress > self[i].slot.LastProgress) then result.append(i);
end;

 (*
tGESlot Functions
-------------------
*)

procedure tGESlot.Update(slot : TRSGEOfferStatus);
begin
  with self do
  begin
    OfferType     := slot.OfferType;
    Item          := slot.Item;
    Quantity      := slot.Quantity;;
    PricePerItem  := slot.PricePerItem;
    TotalPrice    := slot.TotalPrice;
    Progress      := slot.Progress;
  end;
end;

(*
tGEOffer.updateSlot
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGESlot.update();
Updates the slot from mainscreen information.
*)

procedure tGEOffer.updateSlot();
begin
  if self.slotNumber > -1 then
  begin
    self.slot.update(grandExchange.GetOfferStatus(self.slotNumber));
    if  self.slot.OfferType = ERSGEOfferType.UNKNOWN then
    begin
      takeScreenshot('slot'+toStr(self.slotNumber)+'_unknown.png');
      grandExchange.MouseOffSlots();
      wait(random(400,800));
      self.slot.update(grandExchange.GetOfferStatus(self.slotNumber));
    end;
  end;
end;

procedure tGEOfferArray.updateSlots();
var i : Int32;
begin
  for i := 0 to high(self) do
    self[i].updateSlot();
end;

function tGEOffer.getStackedItem() : Int32;
var
  i : Int32;
begin
  if length(self.InvSlots) = 0 then Exit(-1);

  for i := 0 to high(self.InvSlots) do
    if Inventory.IsSlotNoted(self.invSlots[i]) or (Inventory.ItemInterface.CountStack(self.invSlots[i]) > 1) then
     exit(i);

  result := 0;
end;

function tGEHistory.stringify() : String;
begin
  result := self.offerType + ': ' + self.Item + '. Value: ' + toStr(self.TotalPrice) + '. Quantity: ' + toStr(self.Quantity) + '. Each:  ' + toStr(self.PricePerItem) + '. Used = ' + toStr(self.isUsed) + '. firstPass = ' + toStr(self.firstPass);
end;

procedure tGEHistory.debug();
begin
  print(self.stringify());
end;

procedure tGEHistoryArray.debug();
var
  i, lim : Integer;
begin
  lim := high(self);
  for i := 0 to lim do
    self[i].debug();
end;

(*
tGEHistoryArray.Append
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEHistoryArray.append(const history : tGEHistory);
Appends a history record to the end of the array
*)

procedure tGEHistoryArray.append(constref history : tGEHistory);
begin
  insert(history, self, length(self));
end;

(*
tGEHistoryArray.deleteIndex
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEHistoryArray.deleteIndex(const index : Integer);
Deletes a history record from the list - after collecting new items
*)

procedure tGEHistoryArray.deleteIndex(const index : Integer);
begin
  if not inRange(index, low(self), high(self)) then
  begin
    //tScript.print('ERROR: deleteIndex: index out of bounds.');
    exit();
  end;

  delete(self, index, 1);
end;

procedure tGEHistoryArray.trimUsed();
var
  i, usedCount, deleteTo : Int32;
begin
  for i := 0 to high(self) do
  begin
    if usedCount = 2 then
    begin
      deleteTo := i;
      break;
    end;

    if self[i].isUsed then usedCount += 1;
  end;

  //writeln('DeleteTo: ', deleteTo);

  for i := high(self) downto max(deleteTo, 5) do
    if self[i].isUsed or self[i].firstPass then self.deleteIndex(i);

  // A hacky way of removing lost (unused) items from failed buys
  for i := high(self) downto 5 do
    if (not self[i].isUsed) and (not self[i].firstPass) then self[i].firstPass := True;
end;

function tGEHistory.equals(cmp : tGEHistory) : Boolean;
begin
  result := True;

  if not smartStringMatch(self.Item, cmp.Item, 2) then exit(False);
  if self.OfferType <> cmp.OfferType then exit(False);
  if self.Quantity <> cmp.Quantity then exit(False);
  if self.TotalPrice <> cmp.TotalPrice then exit(False);
  if self.PricePerItem <> cmp.PricePerItem then exit(False);
end;

function tGEHistoryArray.matchLine(constref history : tGEHistory; startLine, endLine : Integer) : Integer;
var
  i, lim : Integer;
begin
  result := -1;

  lim := high(self);
  for i := max(0, startLine) to min(lim, endLine) do
    if self[i].equals(history) then
    begin
      //writeln('Matched ' + history.Item + ' with ' + self[i].Item);
      //writeln('Matched on line ', i);
      exit(i);
    end;
end;

function tGEHistoryArray.matches(cmp: tGEHistoryArray): Boolean;
var
  i : Int32;
  smaller, bigger: tGEHistoryArray;
begin
  if length(self) >= length(cmp) then
  begin
    bigger := copy(self, 0, length(self));
    smaller := copy(cmp, 0, length(cmp));
  end else
  begin
    bigger := copy(cmp, 0, length(cmp));
    smaller := copy(self, 0, length(self));
  end;

  //writeln('Bigger');
  //bigger.debug();
  //writeln('Samller');
  //smaller.debug();

  // The line must match the top of oldHist or else it's not a match ever

  result := True;
  for i := 0 to high(smaller) do
    if not bigger[i].equals(smaller[i]) then
    begin
      //writeln(bigger[i].Item, ' does not equal ', smaller[i].Item);
      exit(False);
    end;
end;

(*
tGEHistoryArray.match
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   function tGEHistoryArray.match(NewHist : tGEHistoryArray) : Integer;
Matches the new history array (NewHist) to the previous history and returns the
index where the match was found. Keeps the old array status (isUsed).
*)
function tGEHistoryArray.match(NewHist : tGEHistoryArray) : Integer;
var
  testHist : tGEHistoryArray;
  i : Integer;
begin
  result := -1;
  if length(self) = 0 then
  begin
    self := NewHist;
    exit(0);
  end;

  for i := 0 to high(newHist) do
  begin
    testHist := copy(newHist, i, (length(NewHist) - i));
    //writeln('Test ', i);
    //testHist.debug();
    if self.matches(testHist) then
    begin
      //writeln('Found match of length ', length(testHist));
      result := length(newHist) - length(testHist);
      break;
    end;
  end;

  //lastMatch := self.matchLine(newHist[high(NewHist)]);
  //result := high(newHist) - lastMatch;

  // If they matched from the first line, no update required
  if result = 0 then exit();

  //writeln('result: ', result);
  if (result > -1) then
    // Delete duplicates
    for i := high(newHist) downto result do
      newHist.deleteIndex(i);

  // Insert remaining at the top
  insert(newHist, self, 0);

  // Removes excess (more than 2) history items that are already logged.
  self.trimUsed();
end;

procedure tGEHistoryArray.Update();

  function CastHist(hist: tRSGEHistory) : tGEHistoryArray;
  var
    tCast : tGEHistory;
    lineItem : TRSGEHistoryItem;
  begin
    for lineItem in hist do
    begin
      with tCast do
      begin
        tCast.OfferType := lineItem.OfferType;
        tCast.Item:= lineItem.Item;
        tCast.Quantity:= lineItem.Quantity;
        tCast.PricePerItem:= lineItem.PricePerItem;
        tCast.TotalPrice:= lineItem.TotalPrice;
        tCast.PreTax:= lineItem.PreTax;
        tCast.Bounds:= lineItem.Bounds;
        tCast.isUsed:= False;
      end;

      result.append(tCast);
    end;
  end;

var
  newHistory : tGEHistoryArray;
  firstPass : Boolean;
  i : Int32;
begin
  grandExchange.changeTab();  // Change to History tab
  wait(random(400,800));

  firstPass := length(self) = 0;

  setLength(newHistory, 0);

  newHistory := CastHist(GrandExchange.GetHistory());
  if length(newHistory) = 0 then
  begin
    GrandExchange.ChangeTab();

    newHistory := CastHist(GrandExchange.GetHistory());
    if length(newHistory) = 0 then
      print('History.Update: Failed to read history', eDebugType.FATAL);
  end;

  if length(newHistory) > 5 then
    if newHistory[5].OfferType = '' then newHistory.deleteIndex(5);

  grandExchange.changeTab(False);
  wait(random(400,800));

  print('New History Debug');
  newHistory.debug();

  print('Old History Debug');
  self.debug();

  self.match(newHistory);

  if firstPass then
    for i := 0 to high(self) do
      self[i].firstPass := True;

  print('Post-Match Debug');
  self.debug();
end;

function tInventorySlot.stringify(slotNum : Int32) : String;
begin
  result := '[' + toStr(slotNum) + ']: ' + Self.Name + ', Stack of ' + toStr(self.count) + '. Exists = ' + toStr(self.exists);
end;

procedure tInventorySlot.debug(slotNum : Int32);
begin
  print(self.stringify(slotNum));

end;

procedure tInventoryArray.debug();
var i : Int32;
begin
  for i := 0 to 27 do
    if self[i].exists then
      self[i].debug(i);
end;

procedure tInventorySlot.reset();
begin
  self.name := '';
  self.count := -1;
  self.exists := False;
end;

procedure tInventorySlot.GetCurrent(InvNumber : Int32);
begin
  if Inventory.IsSlotUsed(InvNumber) then
  begin
    self.exists := True;
    self.count := max(1, Inventory.ItemInterface.CountStack(InvNumber));
  end else
    self.count := -1;
end;

procedure tInventoryArray.GetCurrent();
var
  i : Int32;
begin
  setLength(self, 28);

  for i := 0 to 27 do
    self[i].GetCurrent(i);
end;

function tInventorySlot.IsUpdated(slot : tInventorySlot) : Boolean;
begin
  result := (self.exists <> slot.exists) or (self.count <> slot.count);
end;

function tInventorySlot.IsUpdated(slot : Int32) : Boolean; overload;
var tempSlot : tInventorySlot;
begin
  tempSlot.GetCurrent(slot);
  result := self.IsUpdated(tempSlot);
end;

function tInventorySlot.IsNew(slot : tInventorySlot) : Boolean;
begin
  result := (not self.exists) and slot.exists; // If the old (self) didn't exist and now it does, it's new
end;

procedure tInventoryArray.ClearSlots(slots : tIntegerArray);
var i : Int32;
begin
  print('Clearing inventory slots ' + toStr(slots));
  for i := 0 to high(slots) do
    self[slots[i]].reset();

  self.debug();
end;

function tInventoryArray.HasUpdated() : Boolean;
var
  newInv : tInventoryArray;
  i : Int32;
begin
  newInv.getCurrent();
  for i := 0 to 27 do
  begin
    if self[i].name = 'Coins' then continue;

    if self[i].IsUpdated(newInv[i]) then exit(True);
  end;
end;

function tInventoryArray.GetUpdated(newInv: tInventoryArray; out newSlots : tIntegerArray) : tIntegerArray;
var
  i : Int32;
begin
  for i := 0 to 27 do
  begin
    if self[i].name = 'Coins' then continue;

    if self[i].IsUpdated(newInv[i]) then result.Append(i);
    if self[i].IsNew(newInv[i]) then newSlots.Append(i);
  end;
end;

function tGEOfferArray.SortBySlot() : tIntegerArray;
var
  i, j : Int32;
  tOfferArray : tGEOfferArray;
begin
  tOfferArray := copy(self, 0, 8);
  for i := 0 to high(tOfferArray) do
    tOfferArray[i].globalID := i;  // The globalID is now the real OfferIndex

  for i:=0 to high(tOfferArray) do
    for j:=0 to high(tOfferArray) do
      if (tOfferArray[i].slotNumber < tOfferArray[j].slotNumber) then
        Swap(tOfferArray[i], tOfferArray[j]); // Sort the tempArray by slotNumber

  for i := 0 to high(tOfferArray) do
    result.append(tOfferArray[i].globalID); // Return the indices sorted
end;

function tScript.AddOfferToNextInv(offerIndex : Int32) : Boolean;
var i : Int32;
begin
  for i := 0 to 27 do
  if not self.Inv[i].exists then
  begin
    self.Inv[i].exists := True;
    self.Inv[i].count := max(1, self.offers[offerIndex].purchased);
    self.Inv[i].name := self.offers[offerIndex].item.name;
    exit(true);
  end;
end;

procedure tScript.slotsBestMatches(GESlot : tIntegerArray; var InvSlot : TIntegerArray; newInv : tInventoryArray; resetProgress : Boolean = True);
var
  i, j, matchIndex : Int32;
  bestMatch : Extended;
  InvUptext, namesToMatch : tStringArray;
begin
  if (length(GESlot) = 1) and (length(InvSlot) = 1) then
  begin
    self.offers[GESlot[0]].InvSlots.Append(invSlot[0]);
    self.Inv[invSlot[0]] := newInv[invSlot[0]];
    self.Inv[invSlot[0]].name := self.offers[GESlot[0]].item.name;
    invslot.Del(i, 1);
    exit();
  end;

  setLength(InvUpText, length(InvSlot));
  setLength(namesToMatch, length(GESlot));

  for i := 0 to high(InvSlot) do
  begin
    invUpText[i] := lowercase(Inventory.GetUptext(invSlot[i]).after('Offer').before('/').replace('_', ''));
    if length(invUptext) < 3 then
      invUpText[i] := lowercase(Inventory.GetUptext(invSlot[i], True).after('Offer'));
  end;

  for i := 0 to high(GESlot) do
    namesToMatch[i] := lowercase(self.offers[GESlot[i]].item.name.replace(' ', ''));

  for i := high(InvSlot) downto 0 do
  begin
    if length(GESlot) = 0 then break();

    print('Attempting to match Inventory Slots ' + toStr(invslot) + ' with Offer Indices ' + toStr(geslot));

    for j := 0 to high(GESlot) do
      if (StringMatch(namesToMatch[j], invUpText[i]) > bestMatch) then
      begin
        bestMatch := StringMatch(namesToMatch[j], invUpText[i]);
        matchIndex := j;
      end;

    if not (bestMatch > 0.7) then
    begin
      print('WARNING: Best match was not good: ' + toStr(bestMatch) + ' for uptext = ' + invUpText[i] + ')');
      if not Inventory.IsSlotUsed(InvSlot[i]) then
      begin
        print('Deleting inventory slot ' + toStr(InvSlot[i]) + ' from matching');
        takeScreenshot('InvSlot'+toStr(InvSlot[i]));
        invslot.Del(i, 1);
        bestMatch := -1.0;
        matchIndex := -1;
      end;
    end else
    begin
      print('Matched Inventory ' + toStr(invSlot[i]) + ' (uptext = ' + invUpText[i] + ') with Offer Index ' + toStr(GESlot[matchIndex]) + ' (stripped name = ' + namesToMatch[matchIndex] + ')');
      self.offers[GESlot[matchIndex]].InvSlots.Append(invSlot[i]);
      self.Inv[invSlot[i]] := newInv[invSlot[i]];
      self.Inv[invSlot[i]].name := self.offers[GESlot[matchIndex]].item.name;

      GESlot.Del(matchIndex, 1);
      namesToMatch.Del(matchIndex, 1);
      invslot.Del(i, 1);

      bestMatch := -1.0;
      matchIndex := -1;
    end;
  end;

  if resetProgress and (length(GESlot) > 0) then
  begin
    print('The following Offer Indices were not matched: ' + toStr(GESlot));
    for i := 0 to high(GESlot) do
      self.offers[GESlot[i]].slot.preciseProgress := self.offers[GESlot[i]].slot.LastPreciseProgress;
  end;
end;

function tScript.FindOfferByInv(invSlot : Int32) : Int32;
var i, j : Int32;
begin
  for i := 0 to high(self.offers) do
  begin
    if length(self.offers[i].invSlots) = 0 then continue;

    for j := 0 to high(self.offers[i].InvSlots) do
      if self.offers[i].InvSlots[j] = invSlot then exit(i);

  end;

  result := -1;
end;

procedure tScript.TakeItemScreenshots();
var
  folderName, itemName : String;
  offerIndex, slot : Int32;
  noted, alreadyExists : Boolean;
begin
  if not self.ScreenshotItems then exit();

  for offerIndex := 0 to 7 do
  begin
    if length(self.offers[offerIndex].InvSlots) = 0 then exit()
    else slot := self.offers[offerIndex].InvSlots[0];

    folderName := FormatDateTime('yyyymmdd', Now());
    noted := Inventory.isSlotNoted(slot);

    itemName := toStr(self.offers[offerIndex].item.itemID);
    if noted then itemName += '_noted';

    if not DirectoryExists({$MACRO CURRENT_DIRECTORY} + 'Screenshots/Items/' + folderName) then
      CreateDirectory({$MACRO CURRENT_DIRECTORY} + 'Screenshots/Items/' + folderName);

    alreadyExists := FileExists({$MACRO CURRENT_DIRECTORY} + 'Screenshots/Items/' + folderName + '/' + itemName + '.bmp');

    if not alreadyExists then
      SaveCroppedBitmap({$MACRO CURRENT_DIRECTORY} + 'Screenshots/Items/' + folderName + '/' + itemName + '.bmp', Inventory.GetSlotBox(slot));

  end;
end;

procedure tScript.MatchInventory();
var
  slot, i, oldProgress : Int32;
  changedInv, newSlots, sortedOffers, slotsToMatch, slotsToSkip : tIntegerArray;
  newInv : tInventoryArray;
begin
  sortedOffers := self.offers.SortBySlot();
  //print('Sorted Offer Indices = ' + toStr(sortedOffers));

  newInv.getCurrent();
  changedInv := self.Inv.GetUpdated(newInv, newSlots);
  if length(ChangedInv) = 0 then exit();

  print('Changed Inv Slots: ' + toStr(ChangedInv));
  for i := 0 to high(changedInv) do
  begin
    print('Old Inventory: ' + self.inv[changedInv[i]].stringify(changedInv[i]));
    print('New Inventory: ' + newInv[changedInv[i]].stringify(changedInv[i]));
  end;

  for slot := 0 to 7 do
    //if sortedOffers[slot] in slotsToMatch then
    if length(self.offers[sortedOffers[slot]].invSlots) > 0 then
      for i := 0 to high(self.offers[sortedOffers[slot]].invSlots) do
        if self.offers[sortedOffers[slot]].invSlots[i] in changedInv then
        begin
          print('Updating existing invSlot in offer: ' + toStr(sortedOffers[slot]));
          self.Inv[self.offers[sortedOffers[slot]].invSlots[i]].count := newInv[self.offers[sortedOffers[slot]].invSlots[i]].count;
          self.offers[sortedOffers[slot]].slot.preciseProgress := grandExchange.GetPreciseProgress(self.offers[sortedOffers[slot]].slotNumber);

          changedInv.Del(changedInv.Find(self.offers[sortedOffers[slot]].invSlots[i]), 1);
          slotsToSkip.Append(sortedOffers[slot]);
          break();
        end;

  slotsToMatch := self.offers.ListCollectedBuys();
  for slot := 0 to 7 do
  begin
    if sortedOffers[slot] in slotsToSkip then continue;
    if self.offers[sortedOffers[slot]].collected or (not (self.offers[sortedOffers[slot]].status = 'buying')) then continue;

    self.offers[sortedOffers[slot]].slot.lastPreciseProgress := oldProgress := self.offers[sortedOffers[slot]].slot.preciseProgress;
    self.offers[sortedOffers[slot]].slot.preciseProgress := grandExchange.GetPreciseProgress(self.offers[sortedOffers[slot]].slotNumber);

    if self.offers[sortedOffers[slot]].slot.preciseProgress > oldProgress then
    begin
      print('Found progress change in offer: ' + toStr(sortedOffers[slot]));

      // Double check that ChangedInv didn't miss anything, and run through the existing slots for this item
      if length(self.offers[sortedOffers[slot]].invSlots) > 0 then
      begin
        // First check to see if the inv actually changed, then update the entry if it was
        for i := 0 to high(self.offers[sortedOffers[slot]].invSlots) do
          if self.Inv[self.offers[sortedOffers[slot]].invSlots[i]].isUpdated(self.offers[sortedOffers[slot]].invSlots[i]) then
          begin
            print('Updating existing invSlot in offer: ' + toStr(sortedOffers[slot]));
            self.Inv[self.offers[sortedOffers[slot]].invSlots[i]].count := newInv[self.offers[sortedOffers[slot]].invSlots[i]].count;
            if changedInv.Find(self.offers[sortedOffers[slot]].invSlots[i]) then
              changedInv.Del(changedInv.Find(self.offers[sortedOffers[slot]].invSlots[i]), 1);
            slotsToSkip.Append(sortedOffers[slot]);
            continue(2);
          end;
      end;

      // If the inv slot didn't update, add it to the toMatch list for later - this is a new addition to inventory
      slotsToMatch.append(sortedOffers[slot]);
    end;
  end;

  for slot := 0 to 27 do
    if (not slot in ChangedInv) and (self.Inv[slot].exists and (self.Inv[slot].name = '')) then
      changedInv.append(slot);

  if length(changedInv) = 0 then
  begin
    for i := 0 to high(slotsToMatch) do
      self.offers[slotsToMatch[i]].slot.preciseProgress := self.offers[slotsToMatch[i]].slot.LastPreciseProgress;

    exit();
  end;

  print('slotsToSkip = ' + toStr(slotsToSkip));

  for slot := 0 to 7 do
    if (sortedOffers[slot] in slotsToSkip) and (sortedOffers[slot] in slotsToMatch) then
      slotsToMatch.Del(slotsToMatch.Find(sortedOffers[slot]), 1);

  print('ChangedInv = ' + toStr(ChangedInv));
  print('slotsToMatch = ' + toStr(slotsToMatch));

  //if length(changedInv) > (length(slotsToMatch) + length(slotsToSkip)) then
  //  print('There are too many items in the inventory to match to slots', eDebugType.FATAL);

  self.SlotsBestMatches(slotsToMatch, changedInv, newInv);

  if (length(changedInv) > 0) then //and (length(slotsToSkip) > 0) then
  begin
    print('Some inventory is still not matched, rechecking all slots to see if a double collection happened');
    //self.SlotsBestMatches(slotsToSkip, changedInv, newInv, False);
    self.SlotsBestMatches(sortedOffers, changedInv, newInv, False);
  end;

  for slot := 0 to 27 do
    if self.Inv[slot].exists and (self.Inv[slot].name = '') then
    begin
      self.Inv.debug();
      print('There is an unmatched inventory slot', eDebugType.FATAL);
    end;

  print('Debug Offers');
  self.offers.debug();
end;

procedure tItemMapArray.append(constref itemMap : tItemMap);
begin
  insert(itemMap, self, length(self));
end;

procedure tItemMapArray.deleteIndex(const index : Integer);
begin
  if not inRange(index, low(self), high(self)) then
  begin
    //tScript.print('ERROR: deleteIndex: index out of bounds.');
    exit();
  end;

  delete(self, index, 1);
end;

procedure tItemMapArray.Randomize();
var i, h : Int32;
begin
  h := high(self);
  for i := 0 to h do
    swap(self[i], self[random(length(self))]);
end;

function tJSONObject.HasAll(keys : tStringArray; checkNull : Boolean = False) : Boolean;
var key : String;
begin
  for key in keys do
    if not self.has(key) then exit(False);

  if checkNull then
    for key in keys do
      if self.isNull(key) then exit(False);

  result := True;
end;

function CreateItemMap(id, limit : Int32; name : String) : tItemMap;
begin
  Result.ID := id;
  Result.Name := name;
  Result.Limit := limit;
end;

procedure tItemMap.UpdateItemMap(json : tJSONObject);
begin
  self.HighVol := json.getInt('highPriceVolume');
  self.LowVol := json.getInt('lowPriceVolume');
  self.AvgHigh := json.getInt('avgHighPrice');
  self.AvgLow := json.getInt('avgLowPrice');
end;

//
// GetSortedItemNamesOnly by Olly
// Improvements to CreateItemMapArray directly from Olly feedback
//

function getSortedItemNamesOnly: TStringList;
var
  i: Integer;
begin
  Result.Init();
  Result.LoadFromFile(AppPath + 'Includes\SRL-T\osr\itemfinder\item-names');
  for i:=0 to Result.getCount()-1 do
    Result.setStrings(i, Copy(Result.getStrings(i), 1, Pos('=', Result.getStrings(i)) - 1)); // remove =1234, just have the names
  Result.SetSorted(True); // Items.Sort() is wrong for this usecase
end;

function tJSONArray.CreateItemMapArray() : tItemMapArray;
var
  i, p, count: Int32;
  tempJSON : tJSONObject;
  tempName : String;
  Items: TStringList;
begin
  //Items := getSortedItemNamesOnly();

  setLength(result, self.length());
  for i := 0 to self.length() - 1 do
  begin
    try
      tempJSON := self.getJSONObject(i);

      if not tempJSON.HasAll(['id', 'name', 'limit'], True) then continue;

      tempName := tempJSON.getString('name');
      p := pos(' (tablet)', tempName);
      if p > 0 then setLength(tempName, p-1);

      //if (Items.IndexOf(tempName) = -1) then continue;

      result[count] := [tempJSON.getInt('id'), tempJSON.getInt('limit'), 0, 0, 0, 0, 0, 0, tempName, 0.0, 0.0];
      inc(count);
    except
    end;
  end;
  SetLength(Result, Count);

  result.Randomize();
  items.Free();
end;

procedure tItemMapArray.AddHourly(HourlyJSON : tJSONObject);
var
  i : Int32;
  Hourly : tJSONObject;
begin
  for i := 0 to high(self) do
  begin
    if not HourlyJSON.has(toStr(self[i].ID)) then continue;

    Hourly := HourlyJSON.getJSONObject(toStr(self[i].ID));

    if not Hourly.HasAll(['highPriceVolume', 'lowPriceVolume', 'avgHighPrice', 'avgLowPrice'], True) then continue;

    self[i].UpdateItemMap(Hourly);
  end;
end;

procedure tScript.UpdateItemMap(HourlyJSON : tJSONObject);
var
  i : Int32;
begin
  self.ItemMap.AddHourly(HourlyJSON);

  for i := 0 to high(self.ItemMap) do
  begin
    if min(self.ItemMap[i].HighVol, self.ItemMap[i].LowVol) > 0 then
      self.ItemMap[i].VolumeFactor := round(min(self.ItemMap[i].HighVol, self.ItemMap[i].LowVol) / self.ItemMap[i].Limit, 2);

    if self.ItemMap[i].AvgLow > 0 then
    begin
      self.ItemMap[i].Tradeable := round(self.PlayerCash / self.ItemMap[i].AvgLow);
      self.ItemMap[i].PercentTradeable := round(100 * (self.ItemMap[i].Tradeable / self.ItemMap[i].Limit), 2);
    end;

    self.ItemMap[i].Value := self.ItemMap[i].AvgLow * self.ItemMap[i].Limit;
  end;
end;

function FilterItem(item : tItemMap; itemFilter : tItemFilter) : Boolean;
begin
  if checkBlackList(item.Name, itemFilter.BlackList) then exit(False);

  Result := (item.PercentTradeable >= itemFilter.MinPercentTradeable)
    and (item.Tradeable >= itemFilter.MinTradeable)
    and (item.VolumeFactor >= itemFilter.MinVolumeFactor)
    and (item.Limit >= itemFilter.MinLimit)
    and (item.AvgLow >= itemFilter.MinPrice)
    and (item.Value >= itemFilter.MinValue);
end;

function tScript.CreateFilteredList() : tStringArray;
var
  i, needed: Int32;
begin
  needed := 4 * round(60/(self.UserItemFilter.MinVolumeFactor*2));

  for i := 0 to high(self.ItemMap) do
  begin
    if length(result) >= needed then exit();

    if FilterItem(self.ItemMap[i], self.UserItemFilter) then result.append(self.ItemMap[i].Name);
  end;

  if length(result) <= needed then
  begin
    print('WARNING: Your item list was only ' + toStr(length(result)) + ' items long, adding default filters to hit ' + toStr(needed), eDebugType.LIGHT);
    for i := 0 to high(self.ItemMap) do
    begin
      if length(result) >= needed then exit();

      if FilterItem(self.ItemMap[i], self.DefaultItemFilter) then result.append(self.ItemMap[i].Name);
    end;
  end;
end;

// Count how many slots have active offers
function tScript.countActiveSlots() : Int32;
var
  i : Int32;
  slot : TRSGEOfferStatus;
begin
  for i := 0 to 7 do
  begin
    slot := grandExchange.GetOfferStatus(i);
    if slot.OfferType <> ERSGEOfferType.UNKNOWN then Result += 1;
  end;
end;

// Count how many slots are empty
function tScript.countFreeSlots() : Int32;
var
  i : Int32;
  slot : TRSGEOfferStatus;
begin
  for i := 0 to 7 do
  begin
    slot := grandExchange.GetOfferStatus(i);
    if slot.OfferType = ERSGEOfferType.EMPTY then Result += 1;
  end;
end;

procedure tScript.OverRideItems();
var
  bmp : Array of tMufasaBitmap;
  items : tStringArray;
  item : String;
  sourcePath : String = {$macro CURRENT_DIRECTORY};
  i, j : Int32;
begin
  SourcePath := SourcePath.Before(DirectorySeparator + 'Include') + DirectorySeparator + 'ItemOverride' + DirectorySeparator;

  items := GetFiles(SourcePath, 'png');

  if length(items) = 0 then exit();
  SetLength(bmp, length(items));

  for item in items do
  begin
    item := item.before('.png');

    bmp[i].Init(Client.GetMBitmaps());
    bmp[i].LoadFromFile(SourcePath + item + '.png');
    bmp[i].setName(Item);
    bmp[i].ReplaceColor(RS_ITEM_SHADOW, 0);

    try
      itemFinder.getItemImages(Item);

      for j := 0 to High(itemFinder.ItemImages) do
        if (itemFinder.ItemImages[j].Name = Item) then
        begin
          itemFinder.ItemImages[j].Images += bmp[i];
          break();
        end;
    except
    end;
  end;
end;

(*
tScript.addTrade
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tScript.addTrade(trade : tTradeRecord);
Adds a given tradeRecord to the recentItem list.
*)

procedure tScript.addTrade(offerIndex, historyIndex : Int32);
var trade : tTradeRecord;
begin
  trade := self.offers[OfferIndex].createTradeRecord(self.history[historyIndex]);

  if trade.Quantity <= 0 then
    print("ERROR: Cannot add trade of 0 amount")
  else
    self.tradeLog.append(trade);
end;

function tScript.countTraded(itemID : Int32) : Integer;
var
  i, lim : Integer;
begin
  lim := high(self.tradeLog);
  for i := lim downto 0 do
  begin
    // Working from newest (last) to oldest (first)
    // Can break the first time it's over 4hrs because they're entered chronologically
    if (getSystemUnix - self.tradeLog[i].timeStampUnix) > (4 * ONE_HOUR) then break();

    if (self.tradeLog[i].OfferType = 'Buy') and (self.tradeLog[i].itemID = itemID) then
      Result += self.tradeLog[i].Quantity;
  end;
end;


function tScript.CashAllowable() : Int32;
begin
  result := round((0.95 * self.playerCash) / self.countFreeSlots());
end;

(*
tGEItem.reset
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEItem.reset();
Resets all the variables to default. Can be used for initializing the item.
*)

procedure tGEItem.reset();
begin
  self.itemID := 0;
  self.name := "";
  self.market := 0;
  self.limit := 0;
  self.buy := 0;
  self.sell := 0;
end;

(*
tGESlot.reset
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGESlot.reset();
Resets all the variables to default. Also resets the offer data for the slot.
*)

procedure tGESlot.reset();
begin
  self.OfferType := ERSGEOfferType.EMPTY;
  self.Item := '';
  self.Quantity := 0;
  self.PricePerItem := 0;
  self.TotalPrice := 0;
  self.Progress := 0;
  self.lastProgress := 0;
  self.PreciseProgress := 0;
  self.LastPreciseProgress := 0;
end;

(*
tGEOffer.reset
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEOffer.reset();
Resets all the variables to default. Can be used for initializing the offer. Also
resets the item inside the offer.
*)

procedure tGEOffer.reset(defaultWait: Int32);
begin
  self.globalID := -1;
  self.purchased := 0;
  self.toTrade := 0;
  self.buyOverride := False;
  self.abandoning := False;
  self.spent := 0;
  self.revenue := 0;
  self.startTime := 0;
  self.lastUpdate := 0;
  self.slotNumber := -1;
  self.waitTime := defaultWait;
  self.status := "empty";
  self.collected := False;
  self.histUpdated := False;
  self.item.reset();
  self.slot.reset();
  setLength(self.invSlots, 0);
end;

(*
tGEOfferArray.reset
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEOfferArray.reset();
Resets all data in all slots.
*)

procedure tGEOfferArray.reset(defaultWait : Int32);
var
  i, lim : Int32;
begin
  lim := high(self);
  for i := 0 to lim do
    self[i].reset(defaultWait);
end;

procedure tScript.setup(defaultWait : Int32 = 0);
begin
  setLength(self.offers, 8);
  self.offers.reset(defaultWait);

  setLength(self.history, 0);
  setLength(self.itemQ, 0);
  setLength(self.tradeLog, 0);
  setLength(self.Inv, 28);

  with self.DefaultItemFilter do
  begin
    MinVolumeFactor := 1.5;
    MinPercentTradeable := 1.0;
    MinTradeable := 5;
    MinValue := 1/32;
    MinLimit := 201;
    MinPrice := 100;
  end;
end;

procedure tScript.init();
var f : Int32;
begin
  if not DirectoryExists({$MACRO CURRENT_DIRECTORY} + 'TradeLogs') then
    CreateDirectory({$MACRO CURRENT_DIRECTORY} + 'TradeLogs');

  if not fileExists({$MACRO CURRENT_DIRECTORY} + 'TradeLogs' + DirectorySeparator + 'log.txt') then
  begin
    f := createFile({$MACRO CURRENT_DIRECTORY} + 'TradeLogs' + DirectorySeparator + 'log.txt');
    closeFile(f);
  end;

  WriteFileContents({$MACRO CURRENT_DIRECTORY} + 'TradeLogs' + DirectorySeparator + 'log.txt', FormatDateTime('yyyy-mm-dd hh:mm:ss', Now()) + ' - Script Start' + STR_NEW_LINE + STR_NEW_LINE, True);

  if not DirectoryExists({$MACRO CURRENT_DIRECTORY} + 'Screenshots') then
    CreateDirectory({$MACRO CURRENT_DIRECTORY} + 'Screenshots');

  if not DirectoryExists({$MACRO CURRENT_DIRECTORY} + 'Screenshots' + DirectorySeparator + 'Items') then
    CreateDirectory({$MACRO CURRENT_DIRECTORY} + 'Screenshots' + DirectorySeparator + 'Items');

  if not DirectoryExists({$MACRO CURRENT_DIRECTORY} + 'Video') then
    CreateDirectory({$MACRO CURRENT_DIRECTORY} + 'Video');

  {$IFHASFILE Includes/WaspLib/utils/recorder/recorder.simba}
  if self.useRecorder then
    self.setupRecorder();
  {$ENDIF}
end;

//procedure tScript.initRecorder();
//begin
//  if not DirectoryExists({$MACRO CURRENT_DIRECTORY} + 'Video') then
//    CreateDirectory({$MACRO CURRENT_DIRECTORY} + 'Video');
//
//  Recorder.Start(GetSimbaTargetWindow(), 30, {$MACRO CURRENT_DIRECTORY} + 'Video')
//end;

procedure TScript.saveTrade(offerIndex : Int32);
var i : Int32;
begin
  WriteFileContents({$MACRO CURRENT_DIRECTORY} + 'TradeLogs' + DirectorySeparator + 'log.txt', self.offers[OfferIndex].stringify(OfferIndex, False, True) + STR_NEW_LINE, True);
  WriteFileContents({$MACRO CURRENT_DIRECTORY} + 'TradeLogs' + DirectorySeparator + 'log.txt', self.offers[OfferIndex].item.stringify() + STR_NEW_LINE, True);

  if self.offers[OfferIndex].globalID > -1 then
    for i := 0 to high(self.tradeLog) do
      if self.tradeLog[i].offerID = self.offers[OfferIndex].globalID then
        WriteFileContents({$MACRO CURRENT_DIRECTORY} + 'TradeLogs' + DirectorySeparator + 'log.txt', '    ' + self.tradeLog[i].stringify() + STR_NEW_LINE, True);
end;

procedure TScript.Free();
begin
  try
    RSClient.Image.Clear();
    //self.itemMap.Free();
    WriteFileContents({$MACRO CURRENT_DIRECTORY} + 'TradeLogs' + DirectorySeparator + 'log.txt', STR_NEW_LINE + STR_NEW_LINE + FormatDateTime('yyyy-mm-dd hh:mm:ss', Now()) + ' - Script End' + STR_NEW_LINE, True);
  except
    Print('Couldnt Free Safely');
  end;

  Print('Did ' + toStr(length(self.CompleteOffers)) + ' trades', eDebugType.LIGHT);
  Print('Spent ' + toStr(self.totalSpend) + ' and made ' + toStr(self.totalRevenue) + ' revenue', eDebugType.LIGHT);
  //Print('Start Cash: ' + toStr(self.starterCash) + ', Current Cash: ' + toStr(self.playerCash));
  //Print('Cash change of: ' + toStr(self.playerCash - self.starterCash));
  Print('A total profit of: ' + toStr(self.totalRevenue - self.totalSpend) + 'gp', eDebugType.LIGHT);
  //Print('Blacklist for next time: ' + toStr(self.UserItemFilter.BlackList), eDebugType.LIGHT);

  Print('You did great out there', eDebugType.LIGHT);
end;

