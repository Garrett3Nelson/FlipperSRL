(*
tTradeRecord Functions
-------------------
*)

(*
CreateTradeRecord
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   function createTradeRecord(time, amount : Int32) : tTradeRecord;
Used to convert integer values to tTradeRecord format for use in tracking
*)

function createTradeRecord(time, itemID, amount : Int32) : tTradeRecord;
begin
  result.amount := amount;
  result.itemID := itemID;
  result.tradeFinished := time;
end;

(*
tTradeRecordArray.Append
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tTradeRecordArray.append(const trade : tTradeRecord);
Appends a trade record to the end of the array
*)

procedure tTradeRecordArray.append(constref trade : tTradeRecord);
begin
  insert(trade, self, length(self));
end;

(*
tTradeRecordArray.deleteIndex
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tTradeRecordArray.deleteIndex(const index : Integer);
Deletes a trade record from the list (after it is past 4 hours)
*)

procedure tTradeRecordArray.deleteIndex(const index : Integer);
begin
  if not inRange(index, low(self), high(self)) then
  begin
    //tScript.print('ERROR: deleteIndex: index out of bounds.');
    exit();
  end;

  delete(self, index, 1);
end;

(*
tGEItemArray.Append
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEItemArray.append(const item : tGEItem);
Appends an item to the end of the array
*)

procedure tGEItemArray.append(constref item : tGEItem);
begin
  insert(item, self, length(self));
end;

(*
tGEItemArray.deleteIndex
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEItemArray.deleteIndex(const index : Integer);
Deletes an item from the array, used for clearing return items
*)

procedure tGEItemArray.deleteIndex(const index : Integer);
begin
  if not inRange(index, low(self), high(self)) then
  begin
    //tScript.print('ERROR: deleteIndex: index out of bounds.');
    exit();
  end;

  delete(self, index, 1);
end;

 (*
tGEItem Functions
-------------------
*)


(*
tGEItem.initFlip
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEItem.initFlip();
Once the pricecheck is complete, the flip is set up so that we sell at the
auto-buy price and buy at the auto-sell price.
*)

procedure tGEItem.initFlip();
var
  temp_buy, temp_sell : Integer;
begin
  if self.buy < self.sell then // if buy is lower that means we've already set up the price
    //tScript.print("Item was set up for flipping already")
  else begin
    temp_buy := min(self.sell, self.buy) + 1; // The low price is for buying
    temp_sell := max(self.sell, self.buy) - 1; // The high price is for selling
    self.buy := temp_buy;
    self.sell := temp_sell;
  end;
end;

(*
tGEItem.margin
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   function tGEOffer.margin() : Extended;
Calculates the margin possible for the item. Used after pricechecking.
*)

function tGEItem.margin() : Extended;
begin
  if min(self.buy, self.sell) = 0 then
    Result := 0.0
  else if (self.buy > self.sell) then // If the item is set for a pricecheck
    Result := 100*(self.buy - self.sell - 2 - self.tax) / self.sell
  else if (self.sell > self.buy) then // If the item is set for a flip (doesn't need -2 because it's already happened)
    Result := 100*(self.sell - self.buy - self.tax) / self.buy;
    // The min/max are used to ensure we calculate the right method (higher - lower)/lower
    // margin := (revenue-spend-2)/spend
    // The 2 is subtracted because when we set up for flip we're going to reduce by 1gp on each side
    // Which gives us the best offer on the GE and a faster flip.
end;

function tGEItem.stringify() : String;
begin
  result := self.name + ": ID = " + toStr(self.itemID) + ", Market = " + toStr(self.market) + ", Buy = " + toStr(self.buy) + ", Sell = " +toStr(self.sell) + ', Margin = ' + toStr(round(self.margin(), 3)) + ", Tax: " + toStr(self.tax) + ", Real Sell: " + toStr(self.RealSell) + ", Real Margin: " + toStr(self.RealSell - min(self.buy, self.sell)) + ", Limit: " + toStr(self.limit);
end;

(*
tGEItem.debug
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   function tGEItem.debug() : String;
Puts the important info about an item into a nice readable string. It reports
itemID, name, market, buy/sell, margin, and limit.
*)

procedure tGEItem.debug();
begin
  writeln(self.stringify());
end;

 (*
tGEOffer Functions
-------------------
*)

(*
tGEOffer.initTime
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEOffer.initTime();
Used to mark the startTime of the offer. Reset() will set to 0 so it needs to be
set when the offer actually starts.
*)

procedure tGEOffer.initTime();
begin
  self.startTime := getSystemUnix();
  self.lastUpdate := self.startTime; // At the beginning these are the same
end;

(*
tGEOffer.updateTrades
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEOffer.updateTrades();
Removes any trade records that are over 4 hours old, to update the limit calculation.
*)

//procedure tGEOffer.updateTrades();
//var
//  cutoff, lim, i : Integer;
//begin
//  cutoff := getSystemUnix() - (4*60*60); // 4 hour cutoff for trades
//
//  lim := high(self.previousTrades);
//
//  for i := lim downto 0 do
//    if self.previousTrades[i].tradeFinished < cutoff then // if it's been longer than 4 hours
//      self.previousTrades.deleteIndex(i);
//end;

(*
tGEOffer.addTrade
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEOffer.addTrade(trade : tTradeRecord);
Adds a trade record to the offer for tracking.
*)

//procedure tGEOffer.addTrade(constref trade : tTradeRecord);
//begin
//  if trade.amount <= 0 then
//    writeln("ERROR: Cannot add trade of 0 amount")
//  else
//    self.previousTrades.append(trade);
//
//  self.updateTrades(); // After appending, check to see if any old records can be removed
//end;

(*
tGEOffer.countTraded
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   function tGEOffer.countTraded() : Integer
Sums up the amount we've traded so far. The next partial offer will be calculated
as limit - countTraded.
*)

//function tGEOffer.countTraded() : Integer;
//var
//  i, lim : Integer;
//begin
//  self.updateTrades(); // Before we count, get rid of any old trades
//  lim := high(self.previousTrades);
//  for i := 0 to lim do
//    Result += self.previousTrades[i].amount
//
//end;

(*
tGESlot.debug
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   function tScript.debug() : String;
Puts the important info about a slot into a nice readable string. It reports
slot number, status, last progress.
*)

procedure tGESlot.debug();
begin
  writeln(toStr(self));
end;

function tGEOffer.stringify(collected : Boolean = True) : String;
begin
  result := 'Offer: ' + toStr(self.globalTrade) + '. Status = ' + self.status + '. slotNumber = ' + toStr(self.slotNumber) + '. toTrade = ' + toStr(self.toTrade) + '. Purchased = ' + toStr(self.purchased) + '. Spent: ' + toStr(self.spent) + '. Revenue: ' + toStr(self.revenue);
  if collected then result += '. Collected: ' + toStr(self.collected) +'. History Updated: ' + toStr(self.HistUpdated);

end;

(*
tGEOffer.debug
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEOffer.debug();
Puts the important info about an offer into a nice readable string. It reports
tradeID, status, toTrade, and purchased.
*)

procedure tGEOffer.debug();
begin
  writeln(self.stringify());
  self.item.debug();
  self.slot.debug();
end;

(*
tGEOfferArray.debug
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEOfferArray.debug();
Debugs all offers.
*)

procedure tGEOfferArray.debug();
var
  i, lim : Int32;
begin
  lim := high(self);
  for i := 0 to lim do
    self[i].debug();
end;

procedure tGEOfferArray.append(constref offer : tGEOffer);
begin
  insert(offer, self, length(self));
end;

(*
tGEOfferArray.countCollected
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   function tGEOfferArray.countCollected();
Counts how many offers are marked collected internally.
*)

function tGEOfferArray.countCollected() : Integer;
var
  i, lim : Int32;
begin
  lim := high(self);
  for i := 0 to lim do
    if self[i].collected then inc(result);
end;

(*
tGEOfferArray.countCollected
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   function tGEOfferArray.countActive();
Counts how many active offers we think we have.
*)

function tGEOfferArray.countActive() : Integer;
var i : Integer;
begin
  for i := 0 to high(self) do
    if ((self[i].globalTrade > 0) and (self[i].status <> 'empty')) then
      result += 1;
end;

// Returns a tIA of the trading slot numbers
function tGEOfferArray.CountTrading() : tIntegerArray;
var
  i : Integer;
begin
  for i := 0 to high(self) do
    if ((self[i].slot.OfferType <> ERSGEOfferType.EMPTY) and (self[i].slot.OfferType <> ERSGEOfferType.UNKNOWN)) then result.append(self[i].slotNumber);
end;

function tGEOfferArray.CountComplete() : Int32;
var
  i : Integer;
begin
  for i := 0 to high(self) do
    if self[i].slot.Progress = 100 then result += 1;
end;

 (*
tGESlot Functions
-------------------
*)

procedure tGESlot.Update(slot : TRSGEOfferStatus);
begin
  with self do
  begin
    OfferType     := slot.OfferType;
    Item          := slot.Item;
    Quantity      := slot.Quantity;;
    PricePerItem  := slot.PricePerItem;
    TotalPrice    := slot.TotalPrice;
    Progress      := slot.Progress;
  end;
end;

(*
tGEOffer.updateSlot
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGESlot.update();
Updates the slot from mainscreen information.
*)

procedure tGEOffer.updateSlot();
begin
  if self.slotNumber > -1 then
    self.slot.update(grandExchange.GetOfferStatus(self.slotNumber));
end;

procedure tGEOfferArray.updateSlots();
var i : Int32;
begin
  for i := 0 to high(self) do
    self[i].updateSlot();
end;

function tGEHistory.stringify() : String;
begin
  result := self.offerType + ': ' + self.Item + '. Value: ' + toStr(self.TotalPrice) + '. Quantity: ' + toStr(self.Quantity) + '. Each:  ' + toStr(self.PricePerItem) + '. Used = ' + toStr(self.isUsed);
end;

procedure tGEHistory.debug();
begin
  writeln(self.stringify());
end;

procedure tGEHistoryArray.debug();
var
  i, lim : Integer;
begin
  lim := high(self);
  for i := 0 to lim do
    self[i].debug();
end;

(*
tGEHistoryArray.Append
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEHistoryArray.append(const history : tGEHistory);
Appends a history record to the end of the array
*)

procedure tGEHistoryArray.append(constref history : tGEHistory);
begin
  insert(history, self, length(self));
end;

(*
tGEHistoryArray.deleteIndex
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEHistoryArray.deleteIndex(const index : Integer);
Deletes a history record from the list - after collecting new items
*)

procedure tGEHistoryArray.deleteIndex(const index : Integer);
begin
  if not inRange(index, low(self), high(self)) then
  begin
    //tScript.print('ERROR: deleteIndex: index out of bounds.');
    exit();
  end;

  delete(self, index, 1);
end;

procedure tGEHistoryArray.trimUsed();
var
  i, usedCount, deleteTo : Int32;
begin
  for i := 0 to high(self) do
  begin
    if usedCount = 2 then
    begin
      deleteTo := i;
      break;
    end;

    if self[i].isUsed then usedCount += 1;
  end;

  // Still want to keep 5 items for matching later
  if deleteTo < 5 then exit();

  for i := high(self) downto deleteTo do
    if self[i].isUsed or self[i].firstPass then self.deleteIndex(i);
end;

function tGEHistoryArray.matchLine(constref history : tGEHistory; startLine : Integer = 0) : Integer;
var
  i, lim : Integer;
begin
  result := -1;

  lim := high(self);
  for i := startLine to lim do
  if (stringMatch(self[i].Item, history.Item) > 0.9) then
    if (self[i].OfferType = history.OfferType) then
      if (self[i].Quantity = history.Quantity) then
        if (self[i].TotalPrice = history.TotalPrice) or ((self[i].PricePerItem = history.PricePerItem) and (history.PricePerItem > 0)) then
        begin
          //writeln('Matched ' + history.Item + ' with ' + self[i].Item);
          //writeln('Matched on line ', i);
          exit(i);
        end;
end;

(*
tGEHistoryArray.match
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   function tGEHistoryArray.match(NewHist : tGEHistoryArray) : Integer;
Matches the new history array (NewHist) to the previous history and returns the
index where the match was found. Keeps the old array status (isUsed).
*)
function tGEHistoryArray.match(NewHist : tGEHistoryArray) : Integer;
var
  i, lim, j, lim2, matches, lastMatch, matchLine : Integer;
begin
  if length(self) = 0 then
  begin
    self := NewHist;
    exit(0);
  end;

  lim := high(self);
  lim2 := high(NewHist);

  for j := 0 to lim do
  begin
    matchLine := NewHist.matchLine(self[j], lastMatch);
    if matchLine >= 0 then
    begin
      lastMatch := matchLine+1;
      if result = 0 then result := matchLine;
      matches += 1;
      if (matches = 2) or (lastMatch > lim) then
        break();
    end else
    begin
      // if match failed failed, matches = 0 again
      matches := 0;
      result := -1;
      if lastMatch > lim then break();
    end;
  end;

  // If they matched from the first line, no update required
  if result = 0 then exit();

  if (result > -1) then
  begin
    // Delete duplicates
    for i := high(newHist) downto result do
      newHist.deleteIndex(i);

    // Insert remaining at the top
    insert(newHist, self, 0);

    // Removes excess (more than 2) history items that are already logged.
    self.trimUsed();
  end;
end;

procedure tGEHistoryArray.Update();

  function CastHist(hist: tRSGEHistory) : tGEHistoryArray;
  var
    tCast : tGEHistory;
    lineItem : TRSGEHistoryItem;
  begin
    for lineItem in hist do
    begin
      with tCast do
      begin
        tCast.OfferType := lineItem.OfferType;
        tCast.Item:= lineItem.Item;
        tCast.Quantity:= lineItem.Quantity;
        tCast.PricePerItem:= lineItem.PricePerItem;
        tCast.TotalPrice:= lineItem.TotalPrice;
        tCast.PreTax:= lineItem.PreTax;
        tCast.Bounds:= lineItem.Bounds;
        tCast.isUsed:= False;
      end;

      result.append(tCast);
    end;
  end;

var
  newHistory : tGEHistoryArray;
  firstPass : Boolean;
  i : Int32;
begin
  grandExchange.changeTab();  // Change to History tab
  wait(random(400,800));

  firstPass := length(self) = 0;

  newHistory := CastHist(GrandExchange.GetHistory());

  grandExchange.changeTab(False);
  wait(random(400,800));

  writeln('New History Debug');
  newHistory.debug();

  writeln('Old History Debug');
  self.debug();

  self.match(newHistory);

  if firstPass then
    for i := 0 to high(self) do
      self[i].firstPass := True;

  writeln('Post-Match Debug');
  self.debug();
end;

// Count how many slots have active offers
function tScript.countActiveSlots() : Int32;
var
  i : Int32;
  slot : TRSGEOfferStatus;
begin
  for i := 0 to 7 do
  begin
    slot := grandExchange.GetOfferStatus(i);
    if slot.OfferType <> ERSGEOfferType.UNKNOWN then Result += 1;
  end;
end;

// Count how many slots are empty
function tScript.countFreeSlots() : Int32;
var
  i : Int32;
  slot : TRSGEOfferStatus;
begin
  for i := 0 to 7 do
  begin
    slot := grandExchange.GetOfferStatus(i);
    if slot.OfferType = ERSGEOfferType.EMPTY then Result += 1;
  end;
end;

procedure tScript.OverRideItems();
var
  bmp : Array of tMufasaBitmap;
  items : tStringArray;
  item : String;
  sourcePath : String = {$macro CURRENT_DIRECTORY};
  i, j : Int32;
begin
  SourcePath := SourcePath.Before(DirectorySeparator + 'Include') + DirectorySeparator + 'ItemOverride' + DirectorySeparator;

  items := GetFiles(SourcePath, 'png');

  if length(items) = 0 then exit();
  SetLength(bmp, length(items));

  for item in items do
  begin
    item := item.before('.png');

    bmp[i].Init(Client.GetMBitmaps());
    bmp[i].LoadFromFile(SourcePath + item + '.png');
    bmp[i].setName(Item);
    bmp[i].ReplaceColor(RS_ITEM_SHADOW, 0);

    try
      itemFinder.getItemImages(Item);

      for j := 0 to High(itemFinder.ItemImages) do
        if (itemFinder.ItemImages[j].Name = Item) then
        begin
          itemFinder.ItemImages[j].Images += bmp[i];
          break();
        end;
    except
    end;
  end;
end;

(*
tScript.updateTrades
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tScript.updateTrades();
Removes any items from the recentItem array that were traded more than 4 hours ago.
*)

procedure tScript.updateTrades();
var
  cutoff, lim, i : Integer;
begin
  cutoff := getSystemUnix() - (4*60*60*1000); // 4 hour cutoff for trade limit

  lim := high(self.recentItems);

  for i := lim downto 0 do
    if self.recentItems[i].tradeFinished < cutoff then // if it's been longer than 4 hours
      self.recentItems.deleteIndex(i);
end;

(*
tScript.addTrade
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tScript.addTrade(trade : tTradeRecord);
Adds a given tradeRecord to the recentItem list.
*)

procedure tScript.addTrade(constref trade : tTradeRecord);
begin
  if trade.amount <= 0 then
    self.print("ERROR: Cannot add trade of 0 amount")
  else
    self.recentItems.append(trade);

  self.updateTrades(); // Update to remove any old trades
end;

function tScript.countTraded(itemID : Int32) : Integer;
var
  i, lim : Integer;
begin
  self.updateTrades(); // Before we count, get rid of any old trades
  lim := high(self.recentItems);
  for i := 0 to lim do
    if self.recentItems[i].itemID = itemID then
      Result += self.recentItems[i].amount
end;


function tScript.CashAllowable() : Int32;
begin
  result := round((0.95 * self.playerCash) / self.countFreeSlots());
end;

(*
tGEItem.reset
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEItem.reset();
Resets all the variables to default. Can be used for initializing the item.
*)

procedure tGEItem.reset();
begin
  self.itemID := 0;
  self.name := "";
  self.market := 0;
  self.limit := 0;
  self.buy := 0;
  self.sell := 0;
end;

(*
tGESlot.reset
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGESlot.reset();
Resets all the variables to default. Also resets the offer data for the slot.
*)

procedure tGESlot.reset();
begin
  self.OfferType := ERSGEOfferType.EMPTY;
  self.Item := '';
  self.Quantity := 0;
  self.PricePerItem := 0;
  self.TotalPrice := 0;
  self.Progress := 0;
  self.lastProgress := 0;
end;

(*
tGEOffer.reset
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEOffer.reset();
Resets all the variables to default. Can be used for initializing the offer. Also
resets the item inside the offer.
*)

procedure tGEOffer.reset(defaultWait: Int32);
begin
  self.globalTrade := 0;
  self.purchased := 0;
  self.toTrade := 0;
  self.buyOverride := False;
  self.abandoning := False;
  self.spent := 0;
  self.revenue := 0;
  self.startTime := 0;
  self.lastUpdate := 0;
  self.slotNumber := -1;
  self.previousTrades := [];
  self.waitTime := defaultWait;
  self.status := "empty";
  self.collected := False;
  self.histUpdated := False;
  self.item.reset();
  self.slot.reset();
end;

(*
tGEOfferArray.reset
~~~~~~~~~~~~~~~~~~~~~~~~~~
.. pascal::
   procedure tGEOfferArray.reset();
Resets all data in all slots.
*)

procedure tGEOfferArray.reset(defaultWait : Int32);
var
  i, lim : Int32;
begin
  lim := high(self);
  for i := 0 to lim do
    self[i].reset(defaultWait);
end;

procedure tScript.setup(defaultWait : Int32 = 0);
begin
  setLength(self.offers, 8);
  self.offers.reset(defaultWait);
  self.logTimer.Init(ONE_SECOND * random(180, 240)); // 3 to 4 minutes to avoid 5 minute timeout

  setLength(self.history, 0);
  setLength(self.itemQ, 0);
  setLength(self.recentItems, 0);
end;

procedure TScript.Free();
begin
  try
    RSClient.Image.Clear();
  except
    Self.Print('Couldnt clear client');
  end;
  Self.Print('Did ' + toStr(length(self.CompleteOffers)) + ' trades');
  Self.Print('Spent ' + toStr(self.totalSpend) + ' and made ' + toStr(self.totalRevenue) + ' revenue');
  Self.Print('A total profit of: ' + toStr(self.totalRevenue - self.totalSpend) + 'gp');

  Self.Print('You did great out there');
  self.itemMap.Free();
end;

