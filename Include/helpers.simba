function getSystemUnix() : Int64;
begin
  result := 1000 * dateTimetoUnix(NowUTC(), True); // Unix is in seconds by default, change to ms to match all SRL functions
end;

procedure print(txt: String; level: eDebugType = eDebugType.DEV);
begin
  if level = eDebugType.FATAL then
  begin
    writeln(FormatDateTime('yyyy-mm-dd hh:mm:ss', Now()), ' [FATAL]: ', txt);
    terminateScript();
  end;

  if bot.debugLevel = eDebugType.NONE then exit();

  if (bot.debugLevel = eDebugType.DEV) or ((bot.debugLevel = eDebugType.LIGHT) and (level = eDebugType.LIGHT)) then
    writeln(FormatDateTime('yyyy-mm-dd hh:mm:ss', Now()), ' [BOT]: ', txt);
end;

procedure takeScreenshot(fileName: string);
begin
  CreateDirectory({$MACRO CURRENT_DIRECTORY} + 'Screenshots' + DirectorySeparator);
  saveScreenshot({$MACRO CURRENT_DIRECTORY} + 'Screenshots' + DirectorySeparator + FormatDateTime('yymmdd_hhmmss', Now()) + '_' + fileName);
end;

function smartStringMatch(source, target : String; diff : Integer) : Boolean;

  function trimBad(text, omit : String) : String;
  var
    bad : String = "'.,-<>?+=()/\*@![]#_:"+#10+#13+#32;
    c : String;
  begin
    result := text;
    for c in bad do
    begin
      //writeln(c);
      if pos(c, omit) > 0 then continue;
      result := replace(result, c, '', [rfReplaceAll]);
    end;
  end;

var
  strLen : Integer;
  matchDiff, allowable : Extended;
  trimSource, trimTar : String;
begin
  source := trimBad(source, target);
  trimSource := trim(replace(source, ' ', '', [rfReplaceAll]));
  trimTar := trim(replace(target, ' ', '', [rfReplaceAll]));

  strLen := length(trimTar);
  matchDiff := stringMatch(trimSource, trimTar);
  allowable := 1.0 - (diff / strLen);

  result := matchDiff >= allowable;
end;

function checkBlackList(name : String; blackList : tStringArray) : Boolean;
var i : Int32;
begin
  name := lowercase(name);
  if isStrInArr(name, False, blackList) then exit(True);

  for i := 0 to high(blackList) do
  begin
    if pos("*", blackList[i]) then
    begin
      if length(blackList[i].Before("*")) > 0 then
        result := pos(blackList[i].Before("*"), name) > 0
      else
        result := pos(blackList[i].After("*"), name) > 0;
    end;

    if result then exit();
  end;
end;

function getIncludeHash() : String;
var
  files : tStringArray;
  f, contents : String;
begin
  files := getFiles({$MACRO CURRENT_DIRECTORY}, 'simba');
  for f in files do
    contents += readFileContents({$MACRO CURRENT_DIRECTORY} + f);

  result := SHA1String(contents);
end;

procedure SaveItemMap(ItemMap: tItemMapArray);
var
  Map : tItemMap;
  StringA, MapLine : tStringArray;
  f : Int32;
begin
  if not FileExists({$MACRO CURRENT_DIRECTORY} + 'map.csv') then
  begin
    f := CreateFile({$MACRO CURRENT_DIRECTORY} + 'map.csv');
    CloseFile(f);
  end;
  MapLine := ['ID', 'Limit', 'Name', 'AvgLow', 'AvgHigh', 'HighVol', 'LowVol', 'VolumeFactor', 'PercentTradeable', 'Tradeable', 'Value'];
  StringA.Append(MapLine.Merge(','));

  for Map in ItemMap do
  begin
    MapLine := [toStr(Map.ID), toStr(Map.Limit), Map.Name, toStr(map.AvgLow), toStr(map.AvgHigh), toStr(map.HighVol), toStr(map.LowVol), toStr(map.VolumeFactor), toStr(map.PercentTradeable), toStr(map.Tradeable), toStr(map.Value)];
    StringA.Append(MapLine.Merge(','));
  end;

  WriteFileContents({$MACRO CURRENT_DIRECTORY} + 'map.csv', StringA.Merge(STR_NEW_LINE) , False);
end;

procedure SaveCroppedBitmap(fileName : String; cropBox : tBox);
var
  mbmp : tMufasaBitmap;
begin
  mbmp.FromClient([cropBox.X1, cropBox.Y1, cropBox.X2, cropBox.Y2]);
  mbmp.SaveToFile(fileName);
  mbmp.Free();
end;

function tRSGrandExchange.GetInterfaceBoxes() : tBoxArray;
var
  buttons : tRSButtonArray;
  i : Int32;
begin
  case self.GetCurrentInterface() of
    ERSGEInterface.OVERVIEW:
    begin
      buttons := self.GetOverviewButtons();
      for i := 0 to 7 do
        if self.GetOfferStatus(i).OfferType = ERSGEOfferType.EMPTY then
          buttons += self.GetOfferCreateButtons(i);
    end;
    ERSGEInterface.OFFER_STATUS:
      buttons := self.GetOfferStatusButtons();
    ERSGEInterface.OFFER_SETUP:
      buttons := self.GetSetupOfferButtons();
  end;

  if length(buttons) = 0 then exit();
  for i := 0 to high(buttons) do
    result.append(buttons[i].Bounds);
end;

procedure tRSGrandExchange.DebugInterface(fileName : String);
var
  mBitmap : tMufasaBitmap;
  ATPA : T2DPointArray;
  tBoxes : tBoxArray;
  i : Int32;
begin
  mBitmap.FromClient();

  tBoxes := self.GetInterfaceBoxes();
  SetLength(ATPA, Length(tBoxes));
  for I := 0 to High(ATPA) do
    ATPA[I] := EdgeFromBox(tBoxes[I]);

  for I := 0 to High(ATPA) do
    mBitmap.DrawTPA(ATPA[I], DEBUG_COLORS[I mod Length(DEBUG_COLORS)]);

  mBitmap.SaveToFile({$MACRO CURRENT_DIRECTORY} + 'Screenshots' + DirectorySeparator + FormatDateTime('yymmdd_hhmmss', Now()) + '_' + fileName);
  mBitmap.Free();
end;


// Helper function for finding the new OSRS Window after RemoteInput pairs
// Example: NewWindow := FindRSWindow(GetSimbaTargetPID());
function FindRSWindow(targetPID : Int32 = -1) : tOSWindow;
var
  Root, Child: TOSWindow;
  windowBox : tBox;
  windowWidth, curWidth : Integer;
begin
  for Root in GetVisibleWindows() do
  begin
    // The PID doesn't change after RemoteInput pairs
    if (targetPID > 0) and (targetPID <> Root.GetPID()) then continue;

    // Only works for vanilla client with this filter
    if (Root.GetTitle() = 'Old School RuneScape') then
    begin
      {$IFDEF WINDOWS}
      for Child in Root.GetChildren() do
        if (Child.GetClassName() = 'SunAwtCanvas') then
        begin
          // get size of this child window
          windowBox := Child.GetBounds();

          // The main RS window is the narrowest
          windowWidth := windowBox.X2 - windowBox.X1;

          if (windowWidth < curWidth) or (curWidth = 0) then
          begin
            curWidth := windowWidth;
            result := Child;
          end;
        end;
      {$ELSE}
      begin
        // Handle linux later
        exit();
      end;
      {$ENDIF}
    end;
  end;
end;

procedure Recorder.Start(seconds: Integer; directory: String; userBox, expBox: TBox = []); static; override;
begin
  Recorder.Start(FindRSWindow(getSimbaTargetPID()), seconds, directory, userBox, expBox);
end;

procedure tScript.SetupRecorder();
var
  userB, expB: TBox;
begin
  userB := Chat.GetDisplayNameBox();
  if userB = Chat.GetLineBoxes()[CHAT_INPUT_LINE] then
    userB := [];

  XPBar.Read();
  expB := XPBar.Bounds();

  Recorder.Start(30, {$MACRO CURRENT_DIRECTORY} + 'Video', userB, expB);
end;

